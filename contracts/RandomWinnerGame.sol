//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RandomWinnerGame  is VRFConsumerBase, Ownable {
    //Chainlink variables
    //the amount of LINK to send with the request
    uint256 public fee;
    //ID of public key against which randomness is generated
    bytes32 public keyHash;

    //Address of the players
    address[] public players;
    //max number of players in one game
    uint8 maxPlayers;
    //variable to indicate if the game has started or not
    bool public gameStarted;
    //the fees for entering the game
    uint256 entryFee;
    //current game id
    uint256 public gameId;

    //emmited when the game starts
    event GameStarted(uint256 gameId, uint8 maxPlayers, uint256 entryFee);
    //emitted when someone joins a game
    event PlayerJoined(uint256 gameId, address player);
    //emitted when the game ends
    event GameEnded(uint256 gameId, address winner, bytes32 requestId);

    /* the constructor inherits a VRFConsumerBase and initiates the values for keyHash,
    fee and gameStarted.
    @param vrfCoordinator address of the VRFCoordinator contract
    @param linkToken address of the LINK token contract
    @param vrfFee the amount of LINK to send with the request
    @param vrfKeyHash ID of public key against which randomness is generated */
    constructor(address vrfCoordinator, address linkToken, bytes32 vrfKeyHash, uint256 vrfFee) VRFConsumerBase(vrfCoordinator, linkToken) public {
        keyHash = vrfKeyHash;
        fee = vrfFee;
        gameStarted = false;
    }

    //startGame starts the game by setting appropriate values for all the variables
    function startGame(uint8 _maxPlayers, uint256 _entryFee) public onlyOwner {
        //check if there is a game already running
        require(!gameStarted, "Juego en progreso");
        //empty the players array
        delete players;
        //set the max players for this game
        maxPlayers = _maxPlayers;
        //set the game started to true
        gameStarted = true;
        //setup the entryFee for the game
        entryFee = _entryFee;
        //set the gameId
        gameId += 1;
        //emit the event
        emit GameStarted(gameId, maxPlayers, entryFee);
    }

    //joinGame is called when a player wants to enter the game
    function joinGame() public payable {
        //check if a game is already running
        require(gameStarted, "Juego no iniciado");
        //check if the value sent by the user matches the entryFee
        require(msg.value == entryFee, "El valor de la entrada no coincide");
        //check if there is still some space left in the game to add another player
        require(players.length < maxPlayers, "No hay espacio para mas jugadores");
        //add the sender to the players list
        players.push(msg.sender);
        emit PlayerJoined(gameId, msg.sender);
        //if the list is full start the winner selection process
        if(players.length == maxPlayers) {
            getRandomWinner();
        }
    }

    /* fulfillRandomness is called by VRFCoordinator when it receives a valid VRF proof.
    This function is overrided to act upon the random number generated by Chainlink VRF.
    @param requestId this ID is unique for the request we sent to the VRF Coordinator
    @param randomness this is a random uint256 generated and returned to us by the VRF Coordinator */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual override {
        //we want out winnerIndex to be in the length from 0 to players.length-1, for this we mod it with the player.length value
        uint256 winnerIndex = randomness % players.length;
        //get the address of the winner from the players array
        address winner = players[winnerIndex];
        //send the ether in the contract to the winner
        (bool sent,) = winner.call{value: address(this).balance}("");
        require(sent, "No se pudo enviar el ether al ganador");
        //emit that the game has ended
        emit GameEnded(gameId, winner, requestId);
        //set the gameStarted to false
        gameStarted = false;
    }

    //getRandomWinner is called to start the process of selecting a random winner
    function getRandomWinner() private  returns (bytes32 requestId){
        /* LINK is an internal interface for Link token found within the VRFConsumerBase.
        Here we use the balanceOf method from that interface to make sure that our contract
        has enough link so that we can request the VRFCoordinator for randomness */
        require(LINK.balanceOf(address(this)) >= fee, "No hay suficiente LINK para solicitar la VRF");
        /* Make a request to the VRF coordinator.
        requestRandomness is a function within the VRFConsumerBase, it starts the process of randomness generation */
        return requestRandomness(keyHash, fee);
    }

    //function to receive Ether. msg.data must be empty
    receive() external payable {}

    //fallback function is called when msg.data is not empty
    fallback() external payable {}
}